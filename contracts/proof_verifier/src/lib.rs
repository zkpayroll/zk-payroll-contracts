#![no_std]

use soroban_sdk::{contract, contractimpl, contracttype, BytesN, Env, Vec};

/// A generic Verification Key for a Groth16 circuit on BN254.
/// 
/// Maps natively to SnarkJS `vkey.json` components.
#[contracttype]
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct VerificationKey {
    /// G1 point (x, y)
    pub alpha: BytesN<64>,
    /// G2 point (x_c0, x_c1, y_c0, y_c1)
    pub beta: BytesN<128>,
    /// G2 point (x_c0, x_c1, y_c0, y_c1)
    pub gamma: BytesN<128>,
    /// G2 point (x_c0, x_c1, y_c0, y_c1)
    pub delta: BytesN<128>,
    /// The linear combination points corresponding to public inputs.
    pub ic: Vec<BytesN<64>>,
}

/// Storage keys for the verifier contract.
#[contracttype]
pub enum DataKey {
    /// Stores the active VerificationKey
    VerificationKey,
}

#[contract]
pub struct ProofVerifier;

#[contractimpl]
impl ProofVerifier {
    /// Initialize the verifier contract with a verification key.
    /// 
    /// This should be called exactly once during deployment/setup.
    pub fn initialize_verifier(env: Env, vk: VerificationKey) {
        if env.storage().persistent().has(&DataKey::VerificationKey) {
            panic!("Verifier already initialized");
        }
        env.storage().persistent().set(&DataKey::VerificationKey, &vk);
    }

    /// Read the currently stored verification key.
    pub fn get_verification_key(env: Env) -> VerificationKey {
        env.storage()
            .persistent()
            .get(&DataKey::VerificationKey)
            .expect("Verifier not initialized")
    }

    /// Verify a BN254 Groth16 proof against the stored Verification Key.
    ///
    /// Accepts a raw 256-byte proof payload generated by SnarkJS and forwards
    /// it to the native Soroban host environment.
    ///
    /// # Arguments
    /// * `proof` - 256-byte payload containing G1 A (64 bytes), G2 B (128 bytes),
    ///   and G1 C (64 bytes).
    /// * `public_inputs` - A list of 32-byte field elements matching the inputs
    ///   the circuit expects.
    ///
    /// # Returns
    /// `true` if the proof is valid for the given inputs under the stored VK.
    pub fn verify_payment_proof(
        env: Env,
        proof: BytesN<256>,
        public_inputs: Vec<BytesN<32>>,
    ) -> bool {
        let vk: VerificationKey = env
            .storage()
            .persistent()
            .get(&DataKey::VerificationKey)
            .expect("Verifier not initialized");

        // The number of provided public inputs must match the expected number of 
        // VerificationKey `ic` points minus 1 (because ic[0] is the constant term).
        if public_inputs.len() != vk.ic.len() - 1 {
            return false;
        }

        // Ideally, this will map perfectly to the upcoming Soroban host function:
        // `env.crypto().verify_groth16(Curve::BN254, &vk_bytes, &proof, &public_inputs)`
        // 
        // As of SDK 21.x, this method is simulated.
        Self::simulated_verify_groth16(&env, &vk, proof, public_inputs)
    }

    // A mock stub representing the native `env.crypto().verify_groth16(..)` call.
    fn simulated_verify_groth16(
        _env: &Env,
        _vk: &VerificationKey,
        _proof: BytesN<256>,
        _public_inputs: Vec<BytesN<32>>,
    ) -> bool {
        // In a real execution environment, the host evaluates:
        // Pi = sum(ic_i * input_i)
        // e(A, B) == e(alpha, beta) * e(ic_0 + Pi, gamma) * e(C, delta)
        true
    }
}

#[cfg(test)]
mod tests;
